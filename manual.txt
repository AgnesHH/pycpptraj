* Requirement
    * Compiling: cython + cpptraj
    * Running: pycpptraj

* FrameArray
    * >>> farray = from pycpptraj import io as mdio
      >>> traj = mdio.iterload("./data/md1_prod.Tc5b.x", "./data/Tc5b.top", chunk=100).next()
      >>> traj[:, :, :] 
      >>> # return numpy array with shape of (100, 304, 3) if has_numpy
      >>> # if not has_numpy: return a list of memoryview arrays (shape= (304, 3))
      >>> # it's safer to use copy=True to convert to numpy array
      >>> arr0 = np.array(traj[:, :, :], copy=True)

* numpy
    * pycpptraj does not depend on numpy but it does have limited feature numpy array-like
      for Frame instance (fancy indexing, ...)
    * to fully use numpy's power, you can expose Frame buffer like:
        * arr0 = np.asarray(frame.buffer) (arr0.shape = (frame.size, ))
        * arr1 = np.asarray(frame.buffer3d) (arr0.shape = (frame.size/3, 3))
    
* Atom mask:
    * To make atom mask consitent with cpptraj, I use index of 1 as starting
        (:2-10@CA --> choosing CA from residue 2 to residue 10)
    * for other things, index starts from 0
        frame.atoms(0) --> xyz coords of 1st atom
* FAQ
    * After updating source code, I got message saying wrong size
        * Solution: run "sh ./clean_cpp.sh" to clean all *.cpp generated from *.pyx files and reinstall
    * ts[0, 0, 0] is not the same as ts[0][0, 0] (ts is Trajing_Single)
        * For some unknow reasons, C++ or Python deallocate memory too soon for ts[0, 0, 0]
          Use ts[0][0, 0]
